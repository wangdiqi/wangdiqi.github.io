---
layout: post
title: "k8s"
subtitle: "基础知识"
date: 2020-10-29 08:00:00
author: "Deetch"
header-img: "img/home-bg-o.jpg"
catalog: true
tags:
    - k8s
---

> "Let's go"


# K8s in Action 阅读笔记

### 书中命令过时
~~~
v1.18之前的版本
kubectl run kubia --image=luksa/kubia --port=8080 --generator=run/v1

v1.18+的版本
kubectl run NAME --image=image [--env="key=value"] [--port=port] [--dry-run=server|client] [--overrides=inline-json] [--command] -- [COMMAND] [args...]

kubectl run --image=luksa/kubia kubia -- labels=example=kubia

kubectl create deployment kubia --image=luksa/kubia --port=8080
kubectl expose deployment kubia --type=LoadBalancer --name kubia-http --port=8080

~~~


## k8s logs

只能保存10M左右，会刷新

~~~
kubectl logs <pod-name> -c <container-name>

若pod重启，需要查看前一个容器的日志
kubectl logs mypod --previous
~~~


## pods

~~~
列出标签项
kubectl get pods --show-lables

结果列列出lable带app和env标签
kubectl get pods -L app,env

给现有pod的新增标签
kubectl lable pods kubia-manual app=kubia-manual-v2

修改现有pod的标签
kubectl lable pods kubia-manual app=kubia-manual-v2 --overwrite

列出键值匹配的pods
kubectl get pods -l env=prod

列出不带env的pods，注意用单引号，双引号bash会解释
kubectl get pods -l '!env'

删除pod，实际上是向进程发送一个SIGTERM信号并等待数秒(默认30s)。若未及时关闭，则发送SIGKILL
kubectl delete pods <pod-name>

通过label删除
kubectl delete po -l creation_method=manual

删除namespace和pod
kubectl delete namespace(ns) custom-namespace

删除pod但保留namespace
kubectl delete pod --all

删除命名空间下的(几乎)所有资源
kubectl delete all --all
~~~

### 标签选择器(label)

包含(或不包含)使用特定键的标签
包含具有特定建和值得标签
包含具有特定建的标签，但其值与我们指定的不同

creation_method!=manual     选择带有creation_method标签，并且值不等于manual的pod
env in (prod,devel)         选择带有env标签且值为prod或devel的pod
env notin (prod,devel)      选择带有env标签，但其值不是prod或devel的pod

### 注解(annotate)

~~~
kubect1 annotate pod kubia-manual mycompany.com/someannotation="foo bar"
~~~

### namespace

~~~
kubect1 get pods --namespace(简化 -n)
kubectl create namespace custom-namespace
kubectl create -f kubia-manual.yaml -n custom-namespace (或者在yaml中metadata加namespace: custom-namespace)
~~~

### 当前上下文中配置 (config)

~~~
alias kcd=`kubectl config set-context $(kubectl config current context) --namespace`
kcd some-namespace在命名空间之间进行切换
~~~


### 存活探针 (liveness probe)

Kubemetes 有以下三种探测容器的机制：
1. HTTP GET探针对容器的 IP 地址（你指定的端口和路径）执行HTTP GET 请求。
   如果探测器收到响应，并且响应状态码不代表错误（换句话说，如果HTTP
   响应状态码是2xx或3xx), 则认为探测成功。如果服务器返回错误响应状态
   码或者根本没有响应，那么探测就被认为是失败的，容器将被重新启动。
2. TCP套接字探针尝试与容器指定端口建立TCP连接。如果连接成功建立，则
   探测成功。否则，容器重新启动。
3. Exec探针在容器内执行任意命令，并检查命令的退出状态码。如果状态码
   是0, 则探测成功。所有其他状态码都被认为失败。


~~~
Last State: Terminated
  Reason: Error
  Exit Code: 137
  Started: Mon, 01 Jan 0001 00:00:00 +0000
  Finished: Sun, 14 May 2017 11:41:38 +0200
Ready: true
Restart Count: 1

Events:
... Killing container with id docker://xxxxx


退出代码为137, 这有特殊的含义 ———— 表示该进程由外部信号终止。数字137是两个数字的总和：
128+x, 其中x是终止进程的信号编号。在这个例子中，x等于9, 这是SIGKILL
的信号编号，意味着这个进程被强行终止。
~~~

### 就绪探针 (readiness probe)



## ReplicationController(最终将被弃用)

一个ReplicationController有三个主要部分
1. label selector 标签选择器
2. replica count  副本个数
3. pod template   pod模板

~~~
kubectl get rc
kubectl describe rc <rc-name>

kubectl scale rc kubia --replicas=10

// 这个会删除rc，也会删除pod
kubectl delete rc 

// 只删除rc，不删除pod
kubectl delete rc --cascade=false
~~~

### kubectl edit

在bash.sh中设置使用不同的编辑器  
export KUBE_EDITOR="/usr/bin/nano"


## ReplicaSet(替换ReplicationController)

通常会通过deployment来创建RS

相比较RC，RS拥有更好的标签选择器  
ReplicationController 的标签选择器只允许包含某个标签的匹配pod, 但ReplicaSet 的选择器还允许匹配缺少某个标签的pod, 或包含特定标签名的pod, 不
管其值如何。

选择器
~~~
matchLabels:
    app: kubia

matchExressions:
- key: app
  # In : Label的值必须与其中一个指定的values匹配
  # NotIn : Label的值与任何指定的values不匹配
  # Exists : pod必须包含一个指定名称的标签(值不重要)，使用此运算符时，不应指定values字段
  # DoesNotExist : pod不得包含有指定名称的标签。values属性不得指定。
  operator: In
  values:
   - kubia

如果指定多个表达式，所有表达式必须为true才可匹配
~~~


## DaemonSet

### 在每个节点上运行一个pod

RC和RS都用于k8s集群上运行部署特定数量的pod。
但是，当你希望pod在集群中的每个节点上运行时(并且每个节点都需要正好一个运行的pod实例)

### 在特定节点上运行pod

这可以通过pod模板中的nodeSelector属性指定。
